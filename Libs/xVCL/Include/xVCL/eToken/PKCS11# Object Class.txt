PKCS11# Object класс     


PKIObject.h 

//---------------------------------------------------------------------------

#ifndef PKIObjectH
#define PKIObjectH

#include <ctime>
#include <vector>
#include <string>
#include <openssl/rsa.h>
#include <openssl/evp.h>
#include <openssl/x509.h>
#include <rsaref/cryptoki.h>
#if defined(__BORLANDC__)
# include <System.hpp>
# include <dstring.h>
# include <systdate.h>
#endif
#include "PKIContainer.h"

class PKI_Token;

typedef std::vector<CK_BYTE> CK_BYTEARRAY;
typedef std::vector<CK_CHAR> CK_STRING;
typedef std::vector<CK_UTF8CHAR> CK_UTF8STRING;
typedef std::vector<CK_BYTE> CK_BIGINTEGER;
//---------------------------------------------------------------------------
//! PKI_Object
class PKI_Object : public PKI_Container {
friend class CKeyPair;
public:
    /** creates a new object. */
    CK_RV CreateObject(
        CK_ATTRIBUTE_PTR        pTemplate   //! points to the object's template
        , CK_ULONG              ulCount     //! is the number of attributes in the template
    );
    /** destorys an object. */
    CK_RV DestroyObject(
        void
    );
    /** get the size of an object in byte. */
    CK_RV GetObjectSize(
        CK_ULONG_PTR            pulSize     //! points to the location that receives the size in bytes of the object
    );
    /** generates a secret key or set of domain parameters, creating a new object. */
    CK_RV GenerateKey(
        CK_MECHANISM_PTR        pMechanism  //! points to the generation mechanism
        , CK_ATTRIBUTE_PTR      pTemplate   //! points to the template for the new key or set of domain parmeters
        , CK_ULONG              ulCount     //! is the number of attributes in the template
    );
    /** generates a public/private key pari, creating new key objects. */
    CK_RV GenerateKeyPair(
        CK_MECHANISM_PTR        pMechanism                  //! points to the key generation mechanism
        , CK_ATTRIBUTE_PTR      pPublicKeyTemplate          //! points to the template for the public key
        , CK_ULONG              ulPublicKeyAttributeCount   //! is the number of attributes in the public-key template
        , CK_ATTRIBUTE_PTR      pPrivateKeyTemplate         //! points to the template for the private key
        , CK_ULONG              ulPrivateKeyAttributeCount  //! is the number of attributes in the private-key template
        , CK_OBJECT_HANDLE_PTR  phPublicKey                 //! points to the location that receives the handle of the new public key
        , CK_OBJECT_HANDLE_PTR  phPrivateKey                //! points to the location that receives the handle of the new private key
    );
    /** obtains the value of one or more attributes of an object. */
    CK_RV GetAttributeValue(
        CK_ATTRIBUTE_PTR        pTemplate   //! points to a template that specifies which attribute values are to be obtained, and receives the attribute values
        , CK_ULONG              ulCount = 1 //! is the number of attributes in the template
    );
    /** modifies the values of one or more attributes of an object. */
    CK_RV SetAttributeValue(
        CK_ATTRIBUTE_PTR        pTemplate   //! points to a template that specifies which attrbute values are to be modified and their new values
        , CK_ULONG              ulCount = 1 //! is the number of attributes in the template
    );
public:
#if defined(__BORLANDC__)
    __property CK_OBJECT_CLASS Class = { read=getOBJECTCLASS, index=CKA_CLASS };
    __property CK_BBOOL IsPrivate = { read=getBOOL, index=CKA_PRIVATE };
    __property CK_BBOOL IsModifiable = { read=getBOOL, index=CKA_MODIFIABLE };
    __property AnsiString Label = { read=getAnsiString, write=setAnsiString, index=CKA_LABEL };
#else
#endif
public:
    CK_BYTE                     getBYTE(int index);
    void                        setBYTE(int index, CK_BYTE val);
    CK_CHAR                     getCHAR(int index)
    {   return getBYTE(index);      }
    void                        setCHAR(int index, CK_CHAR val)
    {   setBYTE(index, val);        }
    CK_UTF8CHAR                 getUTF8CHAR(int index)
    {   return getBYTE(index);      }
    void                        setUTF8CHAR(int index, CK_UTF8CHAR val)
    {   setBYTE(index, val);        }
    CK_BBOOL                    getBOOL(int index)
    {   return getBYTE(index);      }
    void                        setBOOL(int index, CK_BBOOL val)
    {   setBYTE(index, val);        }
    CK_ULONG                    getULONG(int index);
    void                        setULONG(int index, CK_ULONG val);
    CK_OBJECT_CLASS             getOBJECTCLASS(int index)
    {   return getULONG(index);     }
    CK_KEY_TYPE                 getKEYTYPE(int index)
    {   return getULONG(index);     }
    CK_MECHANISM_TYPE           getMECHANISMTYPE(int index)
    {   return getULONG(index);     }
    std::time_t                 getDATE(int index);
    void                        setDATE(int index, std::time_t val);
    CK_BYTEARRAY                getBYTEARRAY(int index);
    CK_BYTEARRAY                getSensBYTEARRAY(int index);
    void                        getBYTEARRAY(int index, CK_BYTEARRAY& val);
    void                        setBYTEARRAY(int index, const CK_BYTEARRAY& val);
    CK_BIGINTEGER               getBIGINTEGER(int index)
    {   return getBYTEARRAY(index); }
    CK_BIGINTEGER               getSensBIGINTEGER(int index)
    {   return getSensBYTEARRAY(index); }
    void                        getBIGINTEGER(int index, CK_BIGINTEGER& val)
    {   getBYTEARRAY(index, val);   }
    void                        setBIGINTEGER(int index, const CK_BIGINTEGER& val)
    {   setBYTEARRAY(index, val);   }
    CK_STRING                   getSTRING(int index)
    {   return getBYTEARRAY(index); }
    void                        getSTRING(int index, CK_STRING& val)
    {   getBYTEARRAY(index, val);   }
    void                        setSTRING(int index, const CK_STRING& val)
    {   setBYTEARRAY(index, val);   }
    CK_UTF8STRING               getUTF8STRING(int index)
    {   return getBYTEARRAY(index); }
    void                        getUTF8STRING(int index, CK_UTF8STRING& val)
    {   getBYTEARRAY(index, val);   }
    void                        setUTF8STRING(int index, const CK_UTF8STRING& val)
    {   setBYTEARRAY(index, val);   }
#if defined(__BORLANDC__)
    AnsiString                  getAnsiString(int index);
    void                        setAnsiString(int index, const AnsiString& val);
    AnsiString                  getUTF8String(int index);
    void                        setUTF8String(int index, const AnsiString& val);
    TDateTime                   getDateTime(int index);
    void                        setDateTime(int index, const TDateTime& val);
#endif
protected:
    PKI_Object(PKI_Token* owner
        , CK_OBJECT_HANDLE objid = CK_INVALID_HANDLE
    );
    virtual ~PKI_Object();
protected:
    CK_OBJECT_HANDLE            hObject;
};
//---------------------------------------------------------------------------
//! PKI_Data
class PKI_Data : public PKI_Object {
public:
    void                        OpenSSL_CreateData(
        CK_BYTE_PTR             pData
        , CK_ULONG              ulDataLen
        , CK_BBOOL              bPrivate = CK_TRUE
    );
    void                        OpenSSL_GetData(
        CK_BYTE_PTR             pData
        , CK_ULONG_PTR          pulDataLen
    );
public:
#if defined(__BORLANDC__)
    __property AnsiString Application = { read=getAnsiString, write=setAnsiString, index=CKA_APPLICATION };
    __property CK_BYTEARRAY ObjectID = { read=getBYTEARRAY, write=setBYTEARRAY, index=CKA_OBJECT_ID };
    __property CK_BYTEARRAY Value = { read=getBYTEARRAY, write=getBYTEARRAY, index=CKA_VALUE };
#else
#endif
public:
    PKI_Data(PKI_Token* owner
        , CK_OBJECT_HANDLE dataid = CK_INVALID_HANDLE
    );
    virtual ~PKI_Data();
};
//---------------------------------------------------------------------------
//! PKI_Key
class PKI_Key : public PKI_Object {
public:
    /** initializes an encryption operation. */
    CK_RV                       EncryptInit(
        CK_MECHANISM_PTR        pMechanism      //! points to the encryption mechanism
    );
    /** encrypts single-part data. */
    CK_RV                       Encrypt(
        CK_BYTE_PTR             pData               //! points to the data
        , CK_ULONG              ulDataLen           //! is the length in bytes of the data
        , CK_BYTE_PTR           pEncryptedData      //! points to the location that receives the encrypted data
        , CK_ULONG_PTR          pulEncryptedDataLen //! points to the location that holds the length in bytes of the encrypted data
    );
    /** continues a multiple-part encryption operation, processing another data part. */
    CK_RV                       EncryptUpdate(
        CK_BYTE_PTR             pPart               //! points to the data part
        , CK_ULONG              ulPartLen           //! is the length of the data part
        , CK_BYTE_PTR           pEncryptedPart      //! points to the location that receives the encrypted data part
        , CK_ULONG_PTR          pulEncryptedPartLen //! points to the location that holds the length in bytes of the encrypted data part
    );
    /** finishes a multiple-part encryption operation. */
    CK_RV                       EncryptFinal(
        CK_BYTE_PTR             pLastEncryptedPart      //! points to the location that receives the last encrypted data part, is any
        , CK_ULONG_PTR          pulLastEncryptedPartLen //! points to the location that holds the length of the last encrypted data part
    );
    /** initializes a decryption operation. */
    CK_RV                       DecryptInit(
        CK_MECHANISM_PTR        pMechanism      //! points to the decryption mechanism
    );
    /** decrypts encrypted data in a single part. */
    CK_RV                       Decrypt(
        CK_BYTE_PTR             pEncryptedData      //! points to the encrypted data
        , CK_ULONG              ulEncryptedDataLen  //! is the length of the encrypted data
        , CK_BYTE_PTR           pData               //! points to the location that receives the recovered data
        , CK_ULONG_PTR          pulDataLen          //! points to the location that holds the length of the recovered data
    );
    /** continues a multiple-part decryption operation, processing another encrypted data part. */
    CK_RV                       DecryptUpdate(
        CK_BYTE_PTR             pEncryptedPart      //! points to the encrypted data part
        , CK_ULONG              ulEncryptedPartLen  //! is the length of the encrypted data part
        , CK_BYTE_PTR           pPart               //! points to the location that receives the recovered data part
        , CK_ULONG_PTR          pulPartLen          //! points to the location that holds the length of the recovered data part
    );
    /** continues a multiple-part decryption operation. */
    CK_RV                       DecryptFinal(
        CK_BYTE_PTR             pLastPart       //! points to the location that receives the last recovered data part
        , CK_ULONG_PTR          pulLastPartLen  //! points to the location that holds the length of the last recovered data part
    );
    /** initializes a signature operation, where the signature is an appendix to the data. */
    CK_RV                       SignInit(
        CK_MECHANISM_PTR        pMechanism      //! points to the ssignature mechanism
    );
    /** signs data in a single part, where the signature is an appendix to the data. */
    CK_RV                       Sign(
        CK_BYTE_PTR             pData           //! points to the data
        , CK_ULONG              ulDataLen       //! is the length of the data
        , CK_BYTE_PTR           pSignature      //! points to the location that receives the signature
        , CK_ULONG_PTR          pulSignatureLen //! points to the location that holds the length of the signature
    );
    /** continues a multiple-part signature operation, processing another data part. */
    CK_RV                       SignUpdate(
        CK_BYTE_PTR             pPart           //! points to the data part
        , CK_ULONG              ulPartLen       //! is the length of the data part
    );
    /** finishes a multiple-part signature operation, returning the signature. */
    CK_RV                       SignFinal(
        CK_BYTE_PTR             pSignature      //! points to the location that receives the signature
        , CK_ULONG_PTR          pulSignatureLen //! points to the location that holds the length of the signature
    );
    /** initializes a signature operation, where the data can be recovered from the signature. */
    CK_RV                       SignRecoverInit(
        CK_MECHANISM_PTR        pMechanism      //! points to the structure that specifies the signature mechanism
    );
    /** signs data in a single operatioj, where the data can be recovered from the signature. */
    CK_RV                       SignRecover(
        CK_BYTE_PTR             pData           //! points to the data
        , CK_ULONG              ulDataLen       //! is the length of the data
        , CK_BYTE_PTR           pSignature      //! points to the location taht receives the signature
        , CK_ULONG_PTR          pulSignatureLen //! points to the location that holds the length of the signature
    );
    /** initializes a verification operation, where the signature is an appendix to the data. */
    CK_RV                       VerifyInit(
        CK_MECHANISM_PTR        pMechanism      //! points to the structure that specifies the verification mechanism
    );
    /** verifies a signature in a signle-part operation, where teh signature is an appendix to the data. */
    CK_RV                       Verify(
        CK_BYTE_PTR             pData           //! points to the data
        , CK_ULONG              ulDataLen       //! is the length of the data
        , CK_BYTE_PTR           pSignature      //! points to the signature
        , CK_ULONG              ulSignatureLen  //! is the length of the signature
    );
    /** continues a multiple-part verification operation, processing another data part. */
    CK_RV                       VerifyUpdate(
        CK_BYTE_PTR             pPart           //! points to the data part
        , CK_ULONG              ulPartLen       //! is the length of the data part
    );
    /** finishes a multiple-part verification operation, checking the signture. */
    CK_RV                       VerifyFinal(
        CK_BYTE_PTR             pSignature      //! points to the signature
        , CK_ULONG              ulSignatureLen  //! is the length of the signature
    );
    /** initializes a signature verification operation, where the data is recovered from the signature. */
    CK_RV                       VerifyRecoverInit(
        CK_MECHANISM_PTR        pMechanism      //! points to the structure that specifies the verification mechanism
    );
    /** verifies a signature in a signle-part operation, where the data is recovered from the signature. */
    CK_RV                       VerifyRecover(
        CK_BYTE_PTR             pSignature      //! points to the signature
        , CK_ULONG              ulSignatureLen  //! is the length of the signature
        , CK_BYTE_PTR           pData           //! points to the location that receives the recovered data
        , CK_ULONG_PTR          pulDataLen      //! points to the location that holds the length of the recovered data
    );
public:
#if defined(__BORLANDC__)
    __property CK_KEY_TYPE KeyType = { read=getKEYTYPE, index=CKA_KEY_TYPE };
    __property CK_BYTEARRAY ID = { read=getBYTEARRAY, write=setBYTEARRAY, index=CKA_ID };
    __property TDateTime StartDate = { read=getDateTime, write=setDateTime, index=CKA_START_DATE};
    __property TDateTime EndDate = { read=getDateTime, write=setDateTime, index=CKA_END_DATE};
    __property CK_BBOOL IsDerive = { read=getBOOL, write=setBOOL, index=CKA_DERIVE };
    __property CK_BBOOL IsLocal = { read=getBOOL, index=CKA_LOCAL };
    __property CK_MECHANISM_TYPE KeyGenMechanism = { read=getMECHANISMTYPE, index=CKA_KEY_GEN_MECHANISM };
#else
#endif  
protected:
    PKI_Key(PKI_Token* owner, CK_OBJECT_HANDLE keyid = CK_INVALID_HANDLE);
    virtual ~PKI_Key();
};
//---------------------------------------------------------------------------
//! CPubPrivKey
class CPubPrivKey {
protected:
    CPubPrivKey(void) {;}
    ~CPubPrivKey() {;}
};
//---------------------------------------------------------------------------
//! CRSAKey
class CRSAKey : public CPubPrivKey {
public:
    virtual void                OpenSSL_CreateRSA(RSA* rsa) = 0;
    virtual RSA*                OpenSSL_GetRSA(void) = 0;
protected:
    CRSAKey(void) {;}
    ~CRSAKey() {;}
protected:
    static CK_MECHANISM         RSAMechanism;
};
CK_MECHANISM                    CRSAKey::RSAMechanism = {
    CKM_RSA_PKCS,       NULL,               0
};
//---------------------------------------------------------------------------
//! PKI_PublicKey
class PKI_PublicKey : public PKI_Key {
public:
    virtual void                OpenSSL_CreateKey(EVP_PKEY* key) = 0;
    virtual EVP_PKEY*           OpenSSL_GetKey(void) = 0;
public:
#if defined(__BORLANDC__)
    __property CK_BYTEARRAY Subject = { read=getBYTEARRAY, write=setBYTEARRAY, index=CKA_SUBJECT };
    __property CK_BBOOL IsEncrypt = { read=getBOOL, write=setBOOL, index=CKA_ENCRYPT };
    __property CK_BBOOL IsVerify = { read=getBOOL, write=setBOOL, index=CKA_VERIFY };
    __property CK_BBOOL IsVerifyRecover = { read=getBOOL, write=setBOOL, index=CKA_VERIFY_RECOVER };
    __property CK_BBOOL IsWrap = { read=getBOOL, write=setBOOL, index=CKA_WRAP };
    __property CK_BBOOL IsTrusted = { read=getBOOL, write=setBOOL, index=CKA_TRUSTED };
#else
#endif
protected:
    PKI_PublicKey(PKI_Token* owner
        , CK_OBJECT_HANDLE pubkeyid = CK_INVALID_HANDLE
    );
public:
    virtual ~PKI_PublicKey();
};
//---------------------------------------------------------------------------
//! PKI_RSAPublicKey
class PKI_RSAPublicKey : public PKI_PublicKey, public CRSAKey {
public:
    CK_RV                       EncryptInit(void);
    CK_RV                       VerifyInit(void);
    CK_RV                       VerifyRecoverInit(void);
    virtual void                OpenSSL_CreateKey(EVP_PKEY* key);
    virtual EVP_PKEY*           OpenSSL_GetKey(void);
    virtual void                OpenSSL_CreateRSA(RSA* rsa);
    virtual RSA*                OpenSSL_GetRSA(void);
public:
#if defined(__BORLANDC__)
    __property CK_BIGINTEGER Modulus = { read=getBIGINTEGER, index=CKA_MODULUS };
    __property CK_ULONG ModulusBits = { read=getULONG, index=CKA_MODULUS_BITS };
    __property CK_BIGINTEGER PublicExponent = { read=getBIGINTEGER, index=CKA_PUBLIC_EXPONENT };
#else
#endif
public:
    PKI_RSAPublicKey(PKI_Token* owner
        , CK_OBJECT_HANDLE rsapubkeyid = CK_INVALID_HANDLE
    );
    virtual ~PKI_RSAPublicKey();
};
//---------------------------------------------------------------------------
//! PKI_PrivateKey
class PKI_PrivateKey : public PKI_Key {
public:
    virtual void                OpenSSL_CreateKey(EVP_PKEY* key) = 0;
    virtual EVP_PKEY*           OpenSSL_GetKey(void) = 0;
public:
#if defined(__BORLANDC__)
    __property CK_BYTEARRAY Subject = { read=getBYTEARRAY, write=setBYTEARRAY, index=CKA_SUBJECT };
    __property CK_BBOOL IsSensitive = { read=getBOOL, write=setBOOL, index=CKA_SENSITIVE };
    __property CK_BBOOL IsDecrypt = { read=getBOOL, write=setBOOL, index=CKA_DECRYPT };
    __property CK_BBOOL IsSign = { read=getBOOL, write=setBOOL, index=CKA_SIGN };
    __property CK_BBOOL IsSignRecover = { read=getBOOL, write=setBOOL, index=CKA_SIGN_RECOVER };
    __property CK_BBOOL IsUnwrap = { read=getBOOL, write=setBOOL, index=CKA_UNWRAP };
    __property CK_BBOOL IsExtractable = { read=getBOOL, write=setBOOL, index=CKA_EXTRACTABLE };
    __property CK_BBOOL IsAlwaysSensitive = { read=getBOOL, index=CKA_ALWAYS_SENSITIVE };
    __property CK_BBOOL IsNeverExtractable = { read=getBOOL, index=CKA_NEVER_EXTRACTABLE };
#else
#endif
protected:
    PKI_PrivateKey(PKI_Token* owner
        , CK_OBJECT_HANDLE privkeyid = CK_INVALID_HANDLE
    );
public:
    virtual ~PKI_PrivateKey();
};
//---------------------------------------------------------------------------
//! PKI_RSAPrivateKey
class PKI_RSAPrivateKey : public PKI_PrivateKey, public CRSAKey {
public:
    CK_RV                       DecryptInit(void);
    CK_RV                       SignInit(void);
    CK_RV                       SignRecoverInit(void);
    virtual void                OpenSSL_CreateKey(EVP_PKEY* key);
    virtual EVP_PKEY*           OpenSSL_GetKey(void);
    virtual void                OpenSSL_CreateRSA(RSA* rsa);
    virtual RSA*                OpenSSL_GetRSA(void);
public:
#if defined(__BORLANDC__)
    __property CK_BIGINTEGER Modulus = { read=getBIGINTEGER, index=CKA_MODULUS };
    __property CK_BIGINTEGER PublicExponent = { read=getBIGINTEGER, index=CKA_PUBLIC_EXPONENT };
    __property CK_BIGINTEGER PrivateExponent = { read=getSensBIGINTEGER, index=CKA_PRIVATE_EXPONENT };
    __property CK_BIGINTEGER Prime1 = { read=getSensBIGINTEGER, index=CKA_PRIME_1 };
    __property CK_BIGINTEGER Prime2 = { read=getSensBIGINTEGER, index=CKA_PRIME_2 };
    __property CK_BIGINTEGER Exponent1 = { read=getSensBIGINTEGER, index=CKA_EXPONENT_1 };
    __property CK_BIGINTEGER Exponent2 = { read=getSensBIGINTEGER, index=CKA_EXPONENT_2 };
    __property CK_BIGINTEGER Coefficient = { read=getSensBIGINTEGER, index=CKA_COEFFICIENT };
#else
#endif
public:
    PKI_RSAPrivateKey(PKI_Token* owner
        , CK_OBJECT_HANDLE rsaprivkeyid = CK_INVALID_HANDLE
    );
    virtual ~PKI_RSAPrivateKey();
};
//---------------------------------------------------------------------------
//! CKeyPair
class CKeyPair {
public:
    virtual void                OpenSSL_CreateKey(EVP_PKEY* key) = 0;
    virtual EVP_PKEY*           OpenSSL_GetKey(void) = 0;
    PKI_PublicKey*              GetPublicKey(void)
    {   return PKIPubKey;   }
    PKI_PrivateKey*             GetPrivateKey(void)
    {   return PKIPrivKey;  }
protected:
    CK_RV                       GenerateKeyPair(
        CK_MECHANISM_PTR        pMechanism
        , CK_ATTRIBUTE_PTR      pPublicKeyTemplate
        , CK_ULONG              ulPublicKeyAttributeCount
        , CK_ATTRIBUTE_PTR      pPrivateKeyTemplate
        , CK_ULONG              ulPrivateKeyAttributeCount
    );
protected:
    CKeyPair(PKI_Token*         token
        , CK_OBJECT_HANDLE      pubkeyid = CK_INVALID_HANDLE
        , CK_OBJECT_HANDLE      privkeyid = CK_INVALID_HANDLE
    );
    virtual ~CKeyPair();
protected:
    PKI_Token*                  Token;
    PKI_PublicKey*              PKIPubKey;
    PKI_PrivateKey*             PKIPrivKey;
};
//---------------------------------------------------------------------------
//! CRSAKeyPair
class CRSAKeyPair : public CKeyPair, public CRSAKey {
public:
    virtual void                OpenSSL_GenerateKeyPair(void);
    virtual void                OpenSSL_CreateKey(EVP_PKEY* key);
    virtual EVP_PKEY*           OpenSSL_GetKey(void);
    virtual void                OpenSSL_CreateRSA(RSA* rsa);
    virtual RSA*                OpenSSL_GetRSA(void);
    PKI_RSAPublicKey*           GetRSAPubKey(void)
    {   return dynamic_cast<PKI_RSAPublicKey*>(PKIPubKey);  }
    PKI_RSAPrivateKey*          GetRSAPrivKey(void)
    {   return dynamic_cast<PKI_RSAPrivateKey*>(PKIPrivKey);}
public:
    CRSAKeyPair(PKI_Token*      token
        , CK_OBJECT_HANDLE      pubkeyid = CK_INVALID_HANDLE
        , CK_OBJECT_HANDLE      privkeyid = CK_INVALID_HANDLE
    );
    virtual ~CRSAKeyPair();
};
//---------------------------------------------------------------------------
//! PKI_SecretKey
class PKI_SecretKey : public PKI_Key {
public:
    void                        OpenSSL_GenerateKey(void);
    void                        OpenSSL_CreateKey(EVP_CIPHER* key);
    EVP_CIPHER*                 OpenSSL_GetKey(void);
public:
#if defined(__BORLANDC__)
    __property CK_BBOOL IsSensitive = { read=getBOOL, write=setBOOL, index=CKA_SENSITIVE };
    __property CK_BBOOL IsEncrypt = { read=getBOOL, write=setBOOL, index=CKA_ENCRYPT };
    __property CK_BBOOL IsDecrypt = { read=getBOOL, write=setBOOL, index=CKA_DECRYPT };
    __property CK_BBOOL IsVerify = { read=getBOOL, write=setBOOL, index=CKA_VERIFY };
    __property CK_BBOOL IsSign = { read=getBOOL, write=setBOOL, index=CKA_SIGN };
    __property CK_BBOOL IsWrap = { read=getBOOL, write=setBOOL, index=CKA_WRAP };
    __property CK_BBOOL IsUnwrap = { read=getBOOL, write=setBOOL, index=CKA_UNWRAP };
    __property CK_BBOOL IsExtractable = { read=getBOOL, write=setBOOL, index=CKA_EXTRACTABLE };
    __property CK_BBOOL IsAlwaysSensitive = { read=getBOOL, index=CKA_ALWAYS_SENSITIVE };
    __property CK_BBOOL IsNeverExtractable = { read=getBOOL, index=CKA_NEVER_EXTRACTABLE };
    __property CK_BYTEARRAY Value = { read=getSensBYTEARRAY, index=CKA_VALUE };
    __property CK_ULONG ValueLen = { read=getULONG, index=CKA_VALUE_LEN };
#else
#endif
public:
    PKI_SecretKey(PKI_Token* owner
        , CK_OBJECT_HANDLE seckeyid = CK_INVALID_HANDLE
    );
    virtual ~PKI_SecretKey();
};
//---------------------------------------------------------------------------
//! PKI_Certificate
class PKI_Certificate : public PKI_Object {
public:
    void                        OpenSSL_CreateCert(X509* cert);
    X509*                       OpenSSL_GetCert(void);
protected:
    void                        PreProcess(X509* cert);
    void                        PostProcess(X509* cert);
public:
#if defined(__BORLANDC__)
    __property CK_BBOOL IsTrusted = { read=getBOOL, index=CKA_TRUSTED };
    __property CK_BYTEARRAY Subject = { read=getBYTEARRAY, index=CKA_SUBJECT };
    __property CK_BYTEARRAY ID = { read=getBYTEARRAY, write=setBYTEARRAY, index=CKA_ID };
    __property CK_BYTEARRAY Issuer = { read=getBYTEARRAY, write=getBYTEARRAY, index=CKA_ISSUER };
    __property CK_BYTEARRAY SerialNumber = { read=getBYTEARRAY, write=getBYTEARRAY, index=CKA_SERIAL_NUMBER };
    __property CK_BYTEARRAY Value = { read=getBYTEARRAY, index=CKA_VALUE };
#else
#endif
public:
    PKI_Certificate(PKI_Token* owner
        , CK_OBJECT_HANDLE certid = CK_INVALID_HANDLE
    );
    virtual ~PKI_Certificate();
};
//---------------------------------------------------------------------------
#endif

 

PKIObject.cpp



#pragma hdrstop

#include <algorithm>
#include <openssl/bio.h>
#include <openssl/x509v3.h>
#if defined(__BORLANDC__)
# include <System.hpp>
# include <DateUtils.hpp>
#endif
#include "PKIError.h"
#include "PKICryptoki.h"
#include "PKIToken.h"
#include "PKIObject.h"
#include "PKIP11Engine.h"

#define TokenOwner    dynamic_cast<PKI_Token*>(Owner)
#define CryptokiOwner dynamic_cast<PKI_Cryptoki*>(TokenOwner->Owner)
#define FunctionList  CryptokiOwner->pFunctionList
//===========================================================================
PKI_Object::PKI_Object(PKI_Token* owner, CK_OBJECT_HANDLE objid)
    : PKI_Container(owner), hObject(objid)
{
}
//---------------------------------------------------------------------------
PKI_Object::~PKI_Object()
{
}
//---------------------------------------------------------------------------
CK_RV PKI_Object::CreateObject(CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount)
{
    return TokenOwner->CreateObject(pTemplate, ulCount, &hObject);
}
//---------------------------------------------------------------------------
CK_RV PKI_Object::DestroyObject(void)
{
    return FunctionList->C_DestroyObject(TokenOwner->hSession, hObject);
}
//---------------------------------------------------------------------------
CK_RV PKI_Object::GetObjectSize(CK_ULONG_PTR pulSize)
{
    return FunctionList->C_GetObjectSize(TokenOwner->hSession, hObject, pulSize);
}
//---------------------------------------------------------------------------
CK_RV PKI_Object::GenerateKey(CK_MECHANISM_PTR pMechanism
    , CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount)
{
    return TokenOwner->GenerateKey(pMechanism, pTemplate, ulCount, &hObject);
}
//---------------------------------------------------------------------------
CK_RV PKI_Object::GenerateKeyPair(CK_MECHANISM_PTR pMechanism
    , CK_ATTRIBUTE_PTR pPublicKeyTemplate, CK_ULONG ulPublicKeyAttributeCount
    , CK_ATTRIBUTE_PTR pPrivateKeyTemplate, CK_ULONG ulPrivateKeyAttributeCount
    , CK_OBJECT_HANDLE_PTR phPublicKey, CK_OBJECT_HANDLE_PTR phPrivateKey)
{
    return TokenOwner->GenerateKeyPair(pMechanism
        , pPublicKeyTemplate, ulPublicKeyAttributeCount
        , pPrivateKeyTemplate, ulPrivateKeyAttributeCount
        , phPublicKey, phPrivateKey);
}
//---------------------------------------------------------------------------
CK_RV PKI_Object::GetAttributeValue(CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount)
{
    return FunctionList->C_GetAttributeValue(TokenOwner->hSession, hObject
        , pTemplate, ulCount);
}
//---------------------------------------------------------------------------
CK_RV PKI_Object::SetAttributeValue(CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount)
{
    return FunctionList->C_SetAttributeValue(TokenOwner->hSession, hObject
        , pTemplate, ulCount);
}
//---------------------------------------------------------------------------
CK_BYTE PKI_Object::getBYTE(int index)
{
    CK_BYTE                     val;
    CK_ATTRIBUTE                Template = {
            index,              &val,               sizeof(val)
    };

    AssertObjectRv(GetAttributeValue(&Template));

    return val;
}
//---------------------------------------------------------------------------
void PKI_Object::setBYTE(int index, CK_BYTE val)
{
    CK_ATTRIBUTE                Template = {
            index,              &val,               sizeof(val)
    };

    AssertObjectRv(SetAttributeValue(&Template));
}
//---------------------------------------------------------------------------
CK_ULONG PKI_Object::getULONG(int index)
{
    CK_ULONG                    val;
    CK_ATTRIBUTE                Template = {
            index,              &val,               sizeof(val)
    };

    AssertObjectRv(GetAttributeValue(&Template));

    return val;
}
//---------------------------------------------------------------------------
void PKI_Object::setULONG(int index, CK_ULONG val)
{
    CK_ATTRIBUTE                Template = {
            index,              &val,               sizeof(val)
    };

    AssertObjectRv(SetAttributeValue(&Template));
}
//---------------------------------------------------------------------------
std::time_t PKI_Object::getDATE(int index)
{
    struct tm                   _tm;
    char                        tmpval[sizeof(CK_DATE) + 1];
    std::time_t                 val;
    CK_ATTRIBUTE                Template = {
            index,              &tmpval,            sizeof(CK_DATE)
    };

    AssertObjectRv(GetAttributeValue(&Template));
    memset(tmpval, 'X', sizeof(tmpval));
    strptime(tmpval, "%Y%m%d", &_tm);
    val = mktime(&_tm);

    return val;
}
//---------------------------------------------------------------------------
void PKI_Object::setDATE(int index, std::time_t val)
{
    char                        tmpval[sizeof(CK_DATE) + 1];
    CK_ATTRIBUTE                Template = {
            index,              &tmpval,            sizeof(CK_DATE)
    };

    strftime(tmpval, sizeof(CK_DATE), "%Y%m%d", gmtime(&val));
    AssertObjectRv(SetAttributeValue(&Template));
}
//---------------------------------------------------------------------------
CK_BYTEARRAY PKI_Object::getBYTEARRAY(int index)
{
    CK_BYTEARRAY                val;

    getBYTEARRAY(index, val);

    return val;
}
//---------------------------------------------------------------------------
CK_BYTEARRAY PKI_Object::getSensBYTEARRAY(int index)
{
    CK_BYTEARRAY                val;

    try {
        getBYTEARRAY(index, val);
    }   catch(PKI_ObjectError& E) {
        val.clear();
    }

    return val;
}
//---------------------------------------------------------------------------
void PKI_Object::getBYTEARRAY(int index, CK_BYTEARRAY& val)
{
    CK_ATTRIBUTE                Template = {
            index,              NULL,               0
    };

    AssertObjectRv(GetAttributeValue(&Template));
    val.resize(Template.ulValueLen);
    Template.pValue = val.begin();
    AssertObjectRv(GetAttributeValue(&Template));
}
//---------------------------------------------------------------------------
void PKI_Object::setBYTEARRAY(int index, const CK_BYTEARRAY& val)
{
    CK_ATTRIBUTE                Template = {
            index,              (void*)val.begin(), val.size()
    };

    AssertObjectRv(SetAttributeValue(&Template));
}
//---------------------------------------------------------------------------
#if defined(__BORLANDC__)
AnsiString PKI_Object::getAnsiString(int index)
{
    CK_STRING                       tmpval;
    AnsiString                  val;

    getBYTEARRAY(index, tmpval);
    val.SetLength(tmpval.size());
    std::copy(tmpval.begin(), tmpval.end(), val.c_str());

    return val;
}
//---------------------------------------------------------------------------
void PKI_Object::setAnsiString(int index, const AnsiString& val)
{
    CK_STRING                   tmpval;
    int                         len = val.Length();
    char*                       p = val.c_str();

    tmpval.resize(len);
    std::copy(p, p+len, tmpval.begin());
    setSTRING(index, tmpval);
}
//---------------------------------------------------------------------------
AnsiString PKI_Object::getUTF8String(int index)
{
    AnsiString                  val;
    UTF8String                  tmpval;

    tmpval = getAnsiString(index);
    val = Utf8ToAnsi(tmpval);

    return val;
}
//---------------------------------------------------------------------------
void PKI_Object::setUTF8String(int index, const AnsiString& val)
{
    UTF8String                  tmpval;

    tmpval = AnsiToUtf8(val);

    setAnsiString(index, tmpval);
}
//---------------------------------------------------------------------------
TDateTime PKI_Object::getDateTime(int index)
{
    return UnixToDateTime(getDATE(index));
}
//---------------------------------------------------------------------------
void PKI_Object::setDateTime(int index, const TDateTime& val)
{
    setDATE(index, DateTimeToUnix(val));
}
#endif
//===========================================================================
PKI_Data::PKI_Data(PKI_Token* owner, CK_OBJECT_HANDLE dataid)
    : PKI_Object(owner, dataid)
{
}
//---------------------------------------------------------------------------
PKI_Data::~PKI_Data()
{
}
//---------------------------------------------------------------------------
void PKI_Data::OpenSSL_CreateData(CK_BYTE_PTR pData, CK_ULONG ulDataLen
    , CK_BBOOL bPrivate)
{
    CK_OBJECT_CLASS             ckObjClass = CKO_DATA;
    CK_BBOOL                    bTokenFlag = CK_TRUE;
    CK_ATTRIBUTE                Template[4] = {
        {   CKA_CLASS,          &ckObjClass,        sizeof(ckObjClass)  },
        {   CKA_TOKEN,          &bTokenFlag,        sizeof(bTokenFlag)  },
        {   CKA_PRIVATE,        &bPrivate,          sizeof(bPrivate)    },
        {   CKA_VALUE,          pData,              ulDataLen           }
    };

    AssertObjectRv(CreateObject(Template, 4));
}
//---------------------------------------------------------------------------
void PKI_Data::OpenSSL_GetData(CK_BYTE_PTR pData, CK_ULONG_PTR pulDataLen)
{
    CK_BYTEARRAY                ckByteArray;

    getBYTEARRAY(CKA_VALUE, ckByteArray);
    if(pData && *pulDataLen>=ckByteArray.size()) {
        std::copy(ckByteArray.begin(), ckByteArray.end(), pData);
    }
    *pulDataLen = ckByteArray.size();
}
//===========================================================================
PKI_Key::PKI_Key(PKI_Token* owner, CK_OBJECT_HANDLE keyid)
    : PKI_Object(owner, keyid)
{
}
//---------------------------------------------------------------------------
PKI_Key::~PKI_Key()
{
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::EncryptInit(CK_MECHANISM_PTR pMechanism)
{
    return FunctionList->C_EncryptInit(TokenOwner->hSession
        , pMechanism, hObject);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::Encrypt(CK_BYTE_PTR pData, CK_ULONG ulDataLen
    , CK_BYTE_PTR pEncryptedData, CK_ULONG_PTR pulEncryptedDataLen)
{
    return FunctionList->C_Encrypt(TokenOwner->hSession
        , pData, ulDataLen, pEncryptedData, pulEncryptedDataLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::EncryptUpdate(CK_BYTE_PTR pPart, CK_ULONG ulPartLen
    , CK_BYTE_PTR pEncryptedPart, CK_ULONG_PTR pulEncryptedPartLen)
{
    return FunctionList->C_EncryptUpdate(TokenOwner->hSession
        , pPart, ulPartLen, pEncryptedPart, pulEncryptedPartLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::EncryptFinal(CK_BYTE_PTR pLastEncryptedPart
    , CK_ULONG_PTR pulLastEncryptedPartLen)
{
    return FunctionList->C_EncryptFinal(TokenOwner->hSession
        , pLastEncryptedPart, pulLastEncryptedPartLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::DecryptInit(CK_MECHANISM_PTR pMechanism)
{
    return FunctionList->C_DecryptInit(TokenOwner->hSession
        , pMechanism, hObject);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::Decrypt(CK_BYTE_PTR pEncryptedData, CK_ULONG ulEncryptedDataLen
    , CK_BYTE_PTR pData, CK_ULONG_PTR pulDataLen)
{
    return FunctionList->C_Decrypt(TokenOwner->hSession
        , pEncryptedData, ulEncryptedDataLen, pData, pulDataLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::DecryptUpdate(CK_BYTE_PTR pEncryptedPart
    , CK_ULONG ulEncryptedPartLen, CK_BYTE_PTR pPart, CK_ULONG_PTR pulPartLen)
{
    return FunctionList->C_DecryptUpdate(TokenOwner->hSession
        , pEncryptedPart, ulEncryptedPartLen, pPart, pulPartLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::DecryptFinal(CK_BYTE_PTR pLastPart, CK_ULONG_PTR pulLastPartLen)
{
    return FunctionList->C_DecryptFinal(TokenOwner->hSession
        , pLastPart, pulLastPartLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::SignInit(CK_MECHANISM_PTR pMechanism)
{
    return FunctionList->C_SignInit(TokenOwner->hSession
        , pMechanism, hObject);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::Sign(CK_BYTE_PTR pData, CK_ULONG ulDataLen
    , CK_BYTE_PTR pSignature, CK_ULONG_PTR pulSignatureLen)
{
    return FunctionList->C_Sign(TokenOwner->hSession
        , pData, ulDataLen, pSignature, pulSignatureLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::SignUpdate(CK_BYTE_PTR pPart, CK_ULONG ulPartLen)
{
    return FunctionList->C_SignUpdate(TokenOwner->hSession
        , pPart, ulPartLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::SignFinal(CK_BYTE_PTR pSignature, CK_ULONG_PTR pulSignatureLen)
{
    return FunctionList->C_SignFinal(TokenOwner->hSession
        , pSignature, pulSignatureLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::SignRecoverInit(CK_MECHANISM_PTR pMechanism)
{
    return FunctionList->C_SignRecoverInit(TokenOwner->hSession
        , pMechanism, hObject);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::SignRecover(CK_BYTE_PTR pData, CK_ULONG ulDataLen
    , CK_BYTE_PTR pSignature, CK_ULONG_PTR pulSignatureLen)
{
    return FunctionList->C_SignRecover(TokenOwner->hSession
        , pData, ulDataLen, pSignature, pulSignatureLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::VerifyInit(CK_MECHANISM_PTR pMechanism)
{
    return FunctionList->C_VerifyInit(TokenOwner->hSession
        , pMechanism, hObject);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::Verify(CK_BYTE_PTR pData, CK_ULONG ulDataLen
    , CK_BYTE_PTR pSignature, CK_ULONG ulSignatureLen)
{
    return FunctionList->C_Verify(TokenOwner->hSession
        , pData, ulDataLen, pSignature, ulSignatureLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::VerifyUpdate(CK_BYTE_PTR pPart, CK_ULONG ulPartLen)
{
    return FunctionList->C_SignUpdate(TokenOwner->hSession
        , pPart, ulPartLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::VerifyFinal(CK_BYTE_PTR pSignature, CK_ULONG ulSignatureLen)
{
    return FunctionList->C_VerifyFinal(TokenOwner->hSession
        , pSignature, ulSignatureLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::VerifyRecoverInit(CK_MECHANISM_PTR pMechanism)
{
    return FunctionList->C_VerifyRecoverInit(TokenOwner->hSession
        , pMechanism, hObject);
}
//---------------------------------------------------------------------------
CK_RV PKI_Key::VerifyRecover(CK_BYTE_PTR pSignature, CK_ULONG ulSignatureLen
    , CK_BYTE_PTR pData, CK_ULONG_PTR pulDataLen)
{
    return FunctionList->C_VerifyRecover(TokenOwner->hSession
        , pSignature, ulSignatureLen, pData, pulDataLen);
}
//===========================================================================
PKI_PublicKey::PKI_PublicKey(PKI_Token* owner, CK_OBJECT_HANDLE pubkeyid)
    : PKI_Key(owner, pubkeyid)
{
}
//---------------------------------------------------------------------------
PKI_PublicKey::~PKI_PublicKey()
{
}
//===========================================================================
PKI_RSAPublicKey::PKI_RSAPublicKey(PKI_Token* owner, CK_OBJECT_HANDLE rsapubkeyid)
    : PKI_PublicKey(owner, rsapubkeyid)
{
}
//---------------------------------------------------------------------------
PKI_RSAPublicKey::~PKI_RSAPublicKey()
{
}
//---------------------------------------------------------------------------
CK_RV PKI_RSAPublicKey::EncryptInit(void)
{
    return PKI_Key::EncryptInit(&RSAMechanism);
}
//---------------------------------------------------------------------------
CK_RV PKI_RSAPublicKey::VerifyInit(void)
{
    return PKI_Key::VerifyInit(&RSAMechanism);
}
//---------------------------------------------------------------------------
CK_RV PKI_RSAPublicKey::VerifyRecoverInit(void)
{
    return PKI_Key::VerifyRecoverInit(&RSAMechanism);
}
//---------------------------------------------------------------------------
void PKI_RSAPublicKey::OpenSSL_CreateKey(EVP_PKEY* key)
{
    OpenSSL_CreateRSA(EVP_PKEY_get1_RSA(key));
}
//---------------------------------------------------------------------------
EVP_PKEY* PKI_RSAPublicKey::OpenSSL_GetKey(void)
{
    EVP_PKEY*                   key = EVP_PKEY_new();

    EVP_PKEY_set1_RSA(key, OpenSSL_GetRSA());

    return key;
}
//---------------------------------------------------------------------------
void PKI_RSAPublicKey::OpenSSL_CreateRSA(RSA* rsa)
{
    CK_OBJECT_CLASS             ckObjClass = CKO_PUBLIC_KEY;
    CK_BBOOL                    bToken = CK_TRUE;
    CK_KEY_TYPE                 ckKeyType = CKK_RSA;
    CK_BYTEARRAY                ckModulus, ckPublicExponent;
    CK_ATTRIBUTE                Template[5] = {
        {   CKA_CLASS,          &ckObjClass,        sizeof(ckObjClass)  },
        {   CKA_TOKEN,          &bToken,            sizeof(bToken)      },
        {   CKA_KEY_TYPE,       &ckKeyType,         sizeof(ckKeyType)   },
        {   CKA_MODULUS,        NULL,               0                   },
        {   CKA_PUBLIC_EXPONENT,    NULL,           0                   }
    };

    ckModulus.resize(BN_num_bytes(rsa->n));
    BN_bn2bin(rsa->n, ckModulus.begin());
    Template[3].pValue = ckModulus.begin();
    Template[3].ulValueLen = ckModulus.size();

    ckPublicExponent.resize(BN_num_bytes(rsa->e));
    BN_bn2bin(rsa->e, ckPublicExponent.begin());
    Template[4].pValue = ckPublicExponent.begin();
    Template[4].ulValueLen = ckPublicExponent.size();

    AssertObjectRv(CreateObject(Template, 5));
}
//---------------------------------------------------------------------------
RSA* PKI_RSAPublicKey::OpenSSL_GetRSA(void)
{
    RSA*                        rsa = RSA_new();
    CK_BYTEARRAY                ckModulus, ckPublicExponent;

    getBIGINTEGER(CKA_MODULUS, ckModulus);
    getBIGINTEGER(CKA_PUBLIC_EXPONENT, ckPublicExponent);

    rsa->n = BN_bin2bn(ckModulus.begin(), ckModulus.size(), NULL);
    rsa->e = BN_bin2bn(ckPublicExponent.begin(), ckPublicExponent.size(), NULL);

    return rsa;
}
//===========================================================================
PKI_PrivateKey::PKI_PrivateKey(PKI_Token* owner, CK_OBJECT_HANDLE privkeyid)
    : PKI_Key(owner, privkeyid)
{
}
//---------------------------------------------------------------------------
PKI_PrivateKey::~PKI_PrivateKey()
{
}
//===========================================================================
PKI_RSAPrivateKey::PKI_RSAPrivateKey(PKI_Token* owner, CK_OBJECT_HANDLE rsaprivkeyid)
    : PKI_PrivateKey(owner, rsaprivkeyid)
{
}
//---------------------------------------------------------------------------
PKI_RSAPrivateKey::~PKI_RSAPrivateKey()
{
}
//---------------------------------------------------------------------------
CK_RV PKI_RSAPrivateKey::DecryptInit(void)
{
    return PKI_Key::DecryptInit(&RSAMechanism);
}
//---------------------------------------------------------------------------
CK_RV PKI_RSAPrivateKey::SignInit(void)
{
    return PKI_Key::SignInit(&RSAMechanism);
}
//---------------------------------------------------------------------------
CK_RV PKI_RSAPrivateKey::SignRecoverInit(void)
{
    return PKI_Key::SignRecoverInit(&RSAMechanism);
}
//---------------------------------------------------------------------------
void PKI_RSAPrivateKey::OpenSSL_CreateKey(EVP_PKEY* key)
{
    OpenSSL_CreateRSA(EVP_PKEY_get1_RSA(key));
}
//---------------------------------------------------------------------------
EVP_PKEY* PKI_RSAPrivateKey::OpenSSL_GetKey(void)
{
    EVP_PKEY*                   key = NULL;

    try {
        key = EVP_PKEY_new();
        EVP_PKEY_set1_RSA(key, OpenSSL_GetRSA());
    }   catch(...) {
        EVP_PKEY_free(key);
        key = NULL;
    }

    return key;
}
//---------------------------------------------------------------------------
void PKI_RSAPrivateKey::OpenSSL_CreateRSA(RSA* rsa)
{
    CK_OBJECT_CLASS             ckObjClass = CKO_PRIVATE_KEY;
    CK_BBOOL                    bToken = CK_TRUE, bPrivate = CK_TRUE;
    CK_KEY_TYPE                 ckKeyType = CKK_RSA;
    CK_BYTEARRAY                ckModulus, ckPublicExponent, ckPrivateExponent;
    CK_ATTRIBUTE                Template[7] = {
        {   CKA_CLASS,          &ckObjClass,        sizeof(ckObjClass)  },
        {   CKA_TOKEN,          &bToken,            sizeof(bToken)      },
        {   CKA_PRIVATE,        &bPrivate,          sizeof(bPrivate)    },
        {   CKA_KEY_TYPE,       &ckKeyType,         sizeof(ckKeyType)   },
        {   CKA_MODULUS,        NULL,               0                   },
        {   CKA_PUBLIC_EXPONENT,    NULL,           0                   },
        {   CKA_PRIVATE_EXPONENT,   NULL,           0                   }
    };

    ckModulus.resize(BN_num_bytes(rsa->n));
    BN_bn2bin(rsa->n, ckModulus.begin());
    Template[4].pValue = ckModulus.begin();
    Template[4].ulValueLen = ckModulus.size();

    ckPublicExponent.resize(BN_num_bytes(rsa->e));
    BN_bn2bin(rsa->e, ckPublicExponent.begin());
    Template[5].pValue = ckPublicExponent.begin();
    Template[5].ulValueLen = ckPublicExponent.size();

    ckPrivateExponent.resize(BN_num_bytes(rsa->e));
    BN_bn2bin(rsa->e, ckPrivateExponent.begin());
    Template[6].pValue = ckPrivateExponent.begin();
    Template[6].ulValueLen = ckPrivateExponent.size();

    AssertObjectRv(CreateObject(Template, 7));
}
//---------------------------------------------------------------------------
RSA* PKI_RSAPrivateKey::OpenSSL_GetRSA(void)
{
    RSA*                        rsa = RSA_new();
    CK_BYTEARRAY                ckModulus, ckPublicExponent;

    getBIGINTEGER(CKA_MODULUS, ckModulus);
    getBIGINTEGER(CKA_PUBLIC_EXPONENT, ckPublicExponent);

    RSA_set_method(rsa, &PKCS11_rsa_method);
    RSA_set_ex_data(rsa, 0, this);
    rsa->n = BN_bin2bn(ckModulus.begin(), ckModulus.size(), NULL);
    rsa->e = BN_bin2bn(ckPublicExponent.begin(), ckPublicExponent.size(), NULL);

    return rsa;
}
//===========================================================================
CKeyPair::CKeyPair(PKI_Token* token
    , CK_OBJECT_HANDLE pubkeyid, CK_OBJECT_HANDLE privkeyid)
    : Token(token)
{
}
//---------------------------------------------------------------------------
CKeyPair::~CKeyPair()
{
    delete PKIPubKey;
    delete PKIPrivKey;
}
//---------------------------------------------------------------------------
CK_RV CKeyPair::GenerateKeyPair(CK_MECHANISM_PTR pMechanism
    , CK_ATTRIBUTE_PTR pPublicKeyTemplate, CK_ULONG ulPublicKeyAttributeCount
    , CK_ATTRIBUTE_PTR pPrivateKeyTemplate, CK_ULONG ulPrivateKeyAttributeCount)
{
    return Token->GenerateKeyPair(pMechanism
        , pPublicKeyTemplate, ulPublicKeyAttributeCount
        , pPrivateKeyTemplate, ulPrivateKeyAttributeCount
        , &PKIPubKey->hObject, &PKIPrivKey->hObject);
}
//===========================================================================
CRSAKeyPair::CRSAKeyPair(PKI_Token* token
    , CK_OBJECT_HANDLE pubkeyid, CK_OBJECT_HANDLE privkeyid)
    : CKeyPair(token, pubkeyid, privkeyid)
{
    PKIPubKey = new PKI_RSAPublicKey(Token, pubkeyid);
    PKIPrivKey = new PKI_RSAPrivateKey(Token, privkeyid);
}
//---------------------------------------------------------------------------
CRSAKeyPair::~CRSAKeyPair()
{
}
//---------------------------------------------------------------------------
void CRSAKeyPair::OpenSSL_GenerateKeyPair(void)
{
    CK_KEY_TYPE                 ckKeyType = CKK_RSA;
    CK_OBJECT_CLASS             ckPubClass = CKO_PUBLIC_KEY;
    CK_OBJECT_CLASS             ckPrivClass = CKO_PRIVATE_KEY;
    CK_BBOOL                    bToken = CK_TRUE;
    CK_BBOOL                    bPrivate = CK_TRUE;
    CK_MECHANISM                ckMechanism = {
            CKM_RSA_PKCS_KEY_PAIR_GEN,  NULL_PTR,   0
    };
    CK_ATTRIBUTE                PubTemplate[5] = {
        {   CKA_CLASS,          &ckPubClass,        sizeof(ckPubClass)  },
        {   CKA_TOKEN,          &bToken,            sizeof(bToken)      },
        {   CKA_KEY_TYPE,       &ckKeyType,         sizeof(ckKeyType)   },
        {   CKA_MODULUS_BITS,   NULL,               sizeof(CK_ULONG)    },
        {   CKA_PUBLIC_EXPONENT,    NULL,           0                   }
    };
    CK_ATTRIBUTE                PrivTemplate[4] = {
        {   CKA_CLASS,          &ckPrivClass,       sizeof(ckPrivClass) },
        {   CKA_TOKEN,          &bToken,            sizeof(bToken)      },
        {   CKA_PRIVATE,        &bPrivate,          sizeof(bPrivate)    },
        {   CKA_KEY_TYPE,       &ckKeyType,         sizeof(ckKeyType)   }
    };

    CK_MECHANISM_INFO           ckMechanismInfo;
    AssertObjectRv(Token->GetMechanismInfo(CKM_RSA_PKCS_KEY_PAIR_GEN
        , &ckMechanismInfo));
    PubTemplate[3].pValue = &ckMechanismInfo.ulMaxKeySize;
//  PubTemplate[3].ulValueLen = sizeof(CK_ULONG);

    BIGNUM*                     bn = BN_new();
    CK_BIGINTEGER               ckPublicExponent;
    BN_init(bn);
    BN_set_word(bn, RSA_F4);
    ckPublicExponent.resize(BN_num_bytes(bn));
    BN_bn2bin(bn, ckPublicExponent.begin());
    PubTemplate[4].pValue = ckPublicExponent.begin();
    PubTemplate[4].ulValueLen = ckPublicExponent.size();

    AssertObjectRv(GenerateKeyPair(&ckMechanism
        , PubTemplate, 5, PrivTemplate, 4)
    );
}
//---------------------------------------------------------------------------
void CRSAKeyPair::OpenSSL_CreateKey(EVP_PKEY* key)
{
    GetRSAPubKey()->OpenSSL_CreateKey(key);
    GetRSAPrivKey()->OpenSSL_CreateKey(key);
}
//---------------------------------------------------------------------------
EVP_PKEY* CRSAKeyPair::OpenSSL_GetKey(void)
{
    return GetRSAPrivKey()->OpenSSL_GetKey();
}
//---------------------------------------------------------------------------
void CRSAKeyPair::OpenSSL_CreateRSA(RSA* rsa)
{
    GetRSAPubKey()->OpenSSL_CreateRSA(rsa);
    GetRSAPrivKey()->OpenSSL_CreateRSA(rsa);
}
//---------------------------------------------------------------------------
RSA* CRSAKeyPair::OpenSSL_GetRSA(void)
{
    return GetRSAPrivKey()->OpenSSL_GetRSA();
}
//===========================================================================
PKI_SecretKey::PKI_SecretKey(PKI_Token* owner, CK_OBJECT_HANDLE seckeyid)
    : PKI_Key(owner, seckeyid)
{
}
//---------------------------------------------------------------------------
PKI_SecretKey::~PKI_SecretKey()
{
}
//---------------------------------------------------------------------------
void PKI_SecretKey::OpenSSL_GenerateKey(void)
{
/*  CK_OBJECT_CLASS             ckObjClass = CKO_SECRET_KEY;
    CK_KEY_TYPE                 ckKeyType = CKK_DES;
    CK_BBOOL                    bToken = CK_TRUE;
    CK_BBOOL                    bPrivate = CK_TRUE;
    CK_ULONG                    ulKeyLen = 8;
    CK_MECHANISM                ckMechanism = {
            CKM_DES_KEY_GEN,    NULL_PTR,           0
    };
    CK_ATTRIBUTE                Template[5] = {
        {   CKA_CLASS,          &ckObjClass,        sizeof(ckObjClass)  },
        {   CKA_TOKEN,          &bToken,            sizeof(bToken)      },
        {   CKA_PRIVATE,        &bPrivate,          sizeof(bPrivate)    },
        {   CKA_KEY_TYPE,       &ckKeyType,         sizeof(ckKeyType)   },
        {   CKA_VALUE_LEN,      &ulKeyLen,          sizeof(ulKeyLen)    }
    };

    AssertObjectRv(PKI_Object::GenerateKey(&ckMechanism, Template, 5));*/
}
//---------------------------------------------------------------------------
void PKI_SecretKey::OpenSSL_CreateKey(EVP_CIPHER* key)
{
/*  CK_OBJECT_CLASS             ckObjClass = CKO_SECRET_KEY;
    CK_KEY_TYPE                 ckKeyType = CKK_DES;
    CK_BBOOL                    bToken = CK_TRUE;
    CK_BBOOL                    bPrivate = CK_TRUE;
    CK_ULONG                    ulKeyLen = 8;
    CK_BYTE                     ckKey[8] = {"12345678"};
    CK_MECHANISM                ckMechanism = {
            CKM_DES_KEY_GEN,    NULL_PTR,           0
    };
    CK_ATTRIBUTE                Template[6] = {
        {   CKA_CLASS,          &ckObjClass,        sizeof(ckObjClass)  },
        {   CKA_TOKEN,          &bToken,            sizeof(bToken)      },
        {   CKA_PRIVATE,        &bPrivate,          sizeof(bPrivate)    },
        {   CKA_KEY_TYPE,       &ckKeyType,         sizeof(ckKeyType)   },
        {   CKA_VALUE_LEN,      &ulKeyLen,          sizeof(ulKeyLen)    },
        {   CKA_VALUE,          &ckKey,             sizeof(ckKey)       }
    };

    AssertObjectRv(CreateObject(Template, 6));*/
}
//---------------------------------------------------------------------------
EVP_CIPHER* PKI_SecretKey::OpenSSL_GetKey(void)
{
//TODO: EVP_CIPHER* PKI_SecretKey::OpenSSL_GetKey(void)
    return NULL;
}
//===========================================================================
PKI_Certificate::PKI_Certificate(PKI_Token* owner, CK_OBJECT_HANDLE certid)
    : PKI_Object(owner, certid)
{
}
//---------------------------------------------------------------------------
PKI_Certificate::~PKI_Certificate()
{
}
//---------------------------------------------------------------------------
void PKI_Certificate::OpenSSL_CreateCert(X509* cert)
{
    CK_OBJECT_CLASS             ckObjClass = CKO_CERTIFICATE;
    CK_CERTIFICATE_TYPE         ckCertType = CKC_X_509;
    CK_BBOOL                    bTokenFlag = CK_TRUE;
    CK_BBOOL                    bTrusted = CK_FALSE;

    CK_ATTRIBUTE                Template[9] = {
        {   CKA_CLASS,          &ckObjClass,        sizeof(ckObjClass)  },
        {   CKA_TOKEN,          &bTokenFlag,        sizeof(bTokenFlag)  },
        {   CKA_CERTIFICATE_TYPE,   &ckCertType,    sizeof(ckCertType)  },
        {   CKA_TRUSTED,        &bTrusted,          sizeof(bTrusted)    },
        {   CKA_SUBJECT,        NULL,               0                   },
        {   CKA_ID,             NULL,               0                   },
        {   CKA_ISSUER,         NULL,               0                   },
        {   CKA_SERIAL_NUMBER,  NULL,               0                   },
        {   CKA_VALUE,          NULL,               0                   }
    };

    BUF_MEM*                    bm;
    BIO                         *bioSubject, *bioIssuer, *bioSerialNumber;
    BIO*                        bioCertificate;

    __try {
        //pre process certificate
        PreProcess(cert);

        bTrusted = !!(cert->ex_flags & (EXFLAG_CA | EXFLAG_SS | EXFLAG_V1));

        bioSubject = BIO_new(BIO_s_mem());
        ASN1_i2d_bio((int(*)())i2d_X509_NAME, bioSubject, (unsigned char*)X509_get_subject_name(cert));
        BIO_get_mem_ptr(bioSubject, &bm);
        Template[4].pValue = bm->data;
        Template[4].ulValueLen = bm->length;

        Template[5].pValue = cert->sha1_hash;
        Template[5].ulValueLen = SHA_DIGEST_LENGTH;

        bioIssuer = BIO_new(BIO_s_mem());
        ASN1_i2d_bio((int(*)())i2d_X509_NAME, bioIssuer, (unsigned char*)X509_get_issuer_name(cert));
        BIO_get_mem_ptr(bioIssuer, &bm);
        Template[6].pValue = bm->data;
        Template[6].ulValueLen = bm->length;

        bioSerialNumber = BIO_new(BIO_s_mem());
        i2a_ASN1_INTEGER(bioSerialNumber, X509_get_serialNumber(cert));
        BIO_get_mem_ptr(bioSerialNumber, &bm);
        Template[7].pValue = bm->data;
        Template[7].ulValueLen = bm->length;

        bioCertificate = BIO_new(BIO_s_mem());
        i2d_X509_bio(bioCertificate, cert);
        BIO_get_mem_ptr(bioCertificate, &bm);
        Template[8].pValue = bm->data;
        Template[8].ulValueLen = bm->length;

        AssertObjectRv(CreateObject(Template, 9));

        //post process certificate
        PostProcess(cert);
    }   __finally {
        BIO_free(bioSubject);
        BIO_free(bioIssuer);
        BIO_free(bioSerialNumber);
        BIO_free(bioCertificate);
    }
}
//---------------------------------------------------------------------------
X509* PKI_Certificate::OpenSSL_GetCert(void)
{
    BIO*                        bioCertificate;
    X509*                       x509 = NULL;
    CK_BYTEARRAY                ckByteArray;

    __try {
        getBYTEARRAY(CKA_VALUE, ckByteArray);

        bioCertificate = BIO_new_mem_buf(ckByteArray.begin(), ckByteArray.size());

        x509 = d2i_X509_bio(bioCertificate, NULL);
        if(x509) {
            PreProcess(x509);
        }
    }   __finally {
        BIO_free(bioCertificate);
    }

    return x509;
}
//---------------------------------------------------------------------------
void PKI_Certificate::PreProcess(X509* cert)
{
    X509_check_purpose(cert, -1, 0);
}
//---------------------------------------------------------------------------
void PKI_Certificate::PostProcess(X509* cert)
{
    const CK_ULONG              ulMaxObjectCount = 64;
    CK_ULONG                    ulObjectCount = 0;
    CK_BYTEARRAY                ckID;
    EVP_PKEY*                   certevp = X509_get_pubkey(cert);
    RSA*                        certrsa = EVP_PKEY_get1_RSA(certevp);
    std::vector<CK_OBJECT_HANDLE>   hObjects(ulMaxObjectCount);

    PreProcess(cert);
    ckID.assign(cert->sha1_hash, cert->sha1_hash+SHA_DIGEST_LENGTH);

    AssertTokenRv(TokenOwner->FindObjectByClass(CKO_PRIVATE_KEY
        , hObjects.begin(), hObjects.size(), &ulObjectCount));
    for(unsigned int i=0; i<ulObjectCount; ++i) {
        PKI_RSAPrivateKey           RSAPrivateKey(TokenOwner, hObjects[i]);
        RSA*                        privrsa = RSAPrivateKey.OpenSSL_GetRSA();

        if(privrsa && certrsa && BN_cmp(privrsa->n, certrsa->n) == 0
            && BN_cmp(privrsa->e, certrsa->e) == 0) {
            RSAPrivateKey.setBYTEARRAY(CKA_ID, ckID);
        }
        RSA_free(privrsa);
    }

    AssertTokenRv(TokenOwner->FindObjectByClass(CKO_PUBLIC_KEY
        , hObjects.begin(), hObjects.size(), &ulObjectCount));
    for(unsigned int i=0; i<ulObjectCount; ++i) {
        PKI_RSAPublicKey            RSAPubliceKey(TokenOwner, hObjects[i]);
        RSA*                        pubrsa = RSAPubliceKey.OpenSSL_GetRSA();

        if(pubrsa && certrsa && BN_cmp(pubrsa->n, certrsa->n) == 0
            && BN_cmp(pubrsa->e, certrsa->e) == 0) {
            RSAPubliceKey.setBYTEARRAY(CKA_ID, ckID);
        }
        RSA_free(pubrsa);
    }
    EVP_PKEY_free(certevp);
}
//===========================================================================



Trackback: http://tb.blog.csdn.net/TrackBack.aspx?PostId=26880
