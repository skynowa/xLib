PKCS11# Token класс     


PKIToken.h

//---------------------------------------------------------------------------

#ifndef PKITokenH
#define PKITokenH

#include <rsaref/cryptoki.h>
#if defined(__BORLANDC__)
# include <System.hpp>
# include <dstring.h>
#endif
#include "PKIContainer.h"

class PKI_Cryptoki;
//---------------------------------------------------------------------------
//! PKI_Token
class PKI_Token : public PKI_Container {
friend class PKI_Object;
friend class PKI_Key;
public:
    /** obtains information about a particular slot in the system. */
    CK_RV GetSlotInfo(
        CK_SLOT_INFO_PTR        pInfo       //! points to the location that receives the slot information
    );
    /** obtains information about a particular token in the system. */
    CK_RV GetTokenInfo(
        CK_TOKEN_INFO_PTR       pInfo       //! points to the location that receives the token information
    );
    /** is used to obtain a list of mechanism types supported by a token. */
    CK_RV GetMechanismList(
        CK_MECHANISM_TYPE_PTR   pMechanismList
        , CK_ULONG_PTR          pulCount    //! points to the location that receives the number of mechanisms
    );
    /** obtains information about a particular mechanism possibly supported by a token. */
    CK_RV GetMechanismInfo(
        CK_MECHANISM_TYPE       type        //! is the type of mechanism
        , CK_MECHANISM_INFO_PTR pInfo       //! points to the location that receives the mechanism information
    );
    /** initializes a token. */
    CK_RV InitToken(
        CK_UTF8CHAR_PTR         pPin        //! points to the SO's initial PIN
        , CK_ULONG              ulPinLen    //! is the length in bytes of the PIN
        , CK_UTF8CHAR_PTR       pLabel      //! points to the 32-byte label of the token
    );
    /** initializes the normal user's PIN. */
    CK_RV InitPIN(
        CK_UTF8CHAR_PTR         pPin        //! points to the normal user's PIN
        , CK_ULONG              ulPinLen    //! is the length in bytes of the PIN
    );
    /** modifies the PIN of the user that is currently logged in, or the
     *  CKU_USER_PIN if the session is not logged in.
     */
    CK_RV SetPIN(
        CK_UTF8CHAR_PTR         pOldPin     //! points to the old PIN
        , CK_ULONG              ulOldLen    //! is the length in bytes of the old PIN
        , CK_UTF8CHAR_PTR       pNewPin     //! points to the new PIN
        , CK_ULONG              ulNewLen    //! is the length in bytes of the new PIN
    );
    /** logs a user into a token. */
    CK_RV Login(
        CK_UTF8CHAR_PTR         pPin        //! points to the user's PIN
        , CK_ULONG              ulPinLen    //! is the length of the PIN
    );
#if defined(__BORLANDC__)
    /** logs a user into a token. */
    CK_RV LoginDialog(
        void
    );
#endif  
    /** logs a SO user into a token. */
    CK_RV LoginSO(
        CK_UTF8CHAR_PTR         pSOPin      //! points to the SO user's PIN
        , CK_ULONG              ulSOPinLen  //! is the length of the SO PIN
    );
    /** logs a user out from a token. */
    CK_RV Logout(
        void
    );
    /** mixes additional seed material into the token's random number generator. */
    CK_RV SeedRandom(
        CK_BYTE_PTR             pSeed       //! points to the seed material
        , CK_ULONG              ulSeedLen   //! is the length in bytes of the seed material
    );
    /** generates random or pseudo-random data. */
    CK_RV GenerateRandom(
        CK_BYTE_PTR             pRandomData //! points to the location that receives the random data
        , CK_ULONG              ulRandomLen //! is the length in bytes of the random or pseudo-random data to be generated
    );
    /** creates a new object. */
    CK_RV CreateObject(
        CK_ATTRIBUTE_PTR        pTemplate   //! points to the object's template
        , CK_ULONG              ulCount     //! is the number of attributes in the template
        , CK_OBJECT_HANDLE_PTR  phObject    //! points to the location that receives the new object's handle
    );
    /** generates a secret key or set of domain parameters, creating a new object. */
    CK_RV GenerateKey(
        CK_MECHANISM_PTR        pMechanism  //! points to the generation mechanism
        , CK_ATTRIBUTE_PTR      pTemplate   //! points to the template for the new key or set of domain parmeters
        , CK_ULONG              ulCount     //! is the number of attributes in the template
        , CK_OBJECT_HANDLE_PTR  phObject    //! points to the location that receives the handle of the new key or set domain parameters
    );
    /** generates a public/private key pari, creating new key objects. */
    CK_RV GenerateKeyPair(
        CK_MECHANISM_PTR        pMechanism                  //! points to the key generation mechanism
        , CK_ATTRIBUTE_PTR      pPublicKeyTemplate          //! points to the template for the public key
        , CK_ULONG              ulPublicKeyAttributeCount   //! is the number of attributes in the public-key template
        , CK_ATTRIBUTE_PTR      pPrivateKeyTemplate         //! points to the template for the private key
        , CK_ULONG              ulPrivateKeyAttributeCount  //! is the number of attributes in the private-key template
        , CK_OBJECT_HANDLE_PTR  phPublicKey                 //! points to the location that receives the handle of the new public key
        , CK_OBJECT_HANDLE_PTR  phPrivateKey                //! points to the location that receives the handle of the new private key
    );
    /** initializes a search for token objects that match a template. */
    CK_RV FindObjectsInit(
        CK_ATTRIBUTE_PTR        pTemplate   //! points th a search template that specifies the attribute values to match
        , CK_ULONG              ulCount     //! is the number of attributes in the search tempate
    );
    /** continues a search for token objects that match a template. */
    CK_RV FindObjects(
        CK_OBJECT_HANDLE_PTR    phObject        //! points to the location that receives that list of additional object handles
        , CK_ULONG              ulMaxObjectCount//! is the maximum number of object handles to be returned
        , CK_ULONG_PTR          pulObjectCount  //! points to the location that receives the actual number of object handles returned
    );
    /** terminates a search for token objects. */
    CK_RV FindObjectsFinal(
        void
    );
    CK_RV FindObjects(
        CK_ATTRIBUTE_PTR        pTemplate           //! points th a search template that specifies the attribute values to match
        , CK_ULONG              ulCount             //! is the number of attributes in the search tempate
        , CK_OBJECT_HANDLE_PTR  phObject            //! points to the location that receives that list of additional object handles
        , CK_ULONG              ulMaxObjectCount    //! is the maximum number of object handles to be returned
        , CK_ULONG_PTR          pulObjectCount      //! points to the location that receives the actual number of object handles returned
    );
    CK_RV FindObjectByClass(
        CK_OBJECT_CLASS         objClass
        , CK_OBJECT_HANDLE_PTR  phObject            //! points to the location that receives that list of additional object handles
        , CK_ULONG              ulMaxObjectCount    //! is the maximum number of object handles to be returned
        , CK_ULONG_PTR          pulObjectCount      //! points to the location that receives the actual number of object handles returned
    );
    CK_RV FindObjectByID(
        CK_BYTE_PTR             pID
        , CK_ULONG              ulIDLen
        , CK_OBJECT_HANDLE_PTR  phObject            //! points to the location that receives that list of additional object handles
        , CK_ULONG              ulMaxObjectCount    //! is the maximum number of object handles to be returned
        , CK_ULONG_PTR          pulObjectCount      //! points to the location that receives the actual number of object handles returned
    );
    CK_RV FindObjectByLabel(
        CK_UTF8CHAR_PTR         pLabel
        , CK_ULONG              ulLabelLen
        , CK_OBJECT_HANDLE_PTR  phObject            //! points to the location that receives that list of additional object handles
        , CK_ULONG              ulMaxObjectCount    //! is the maximum number of object handles to be returned
        , CK_ULONG_PTR          pulObjectCount      //! points to the location that receives the actual number of object handles returned
    );
    CK_RV FindObjectByClassID(
        CK_OBJECT_CLASS         objClass
        , CK_BYTE_PTR           pID
        , CK_ULONG              ulIDLen
        , CK_OBJECT_HANDLE_PTR  phObject            //! points to the location that receives that list of additional object handles
        , CK_ULONG              ulMaxObjectCount    //! is the maximum number of object handles to be returned
        , CK_ULONG_PTR          pulObjectCount      //! points to the location that receives the actual number of object handles returned
    );
    CK_RV FindObjectByClassLabel(
        CK_OBJECT_CLASS         objClass
        , CK_UTF8CHAR_PTR       pLabel
        , CK_ULONG              ulLabelLen
        , CK_OBJECT_HANDLE_PTR  phObject            //! points to the location that receives that list of additional object handles
        , CK_ULONG              ulMaxObjectCount    //! is the maximum number of object handles to be returned
        , CK_ULONG_PTR          pulObjectCount      //! points to the location that receives the actual number of object handles returned
    );
    CK_RV FindObjectByIDLabel(
        CK_BYTE_PTR             pID
        , CK_ULONG              ulIDLen
        , CK_UTF8CHAR_PTR       pLabel
        , CK_ULONG              ulLabelLen
        , CK_OBJECT_HANDLE_PTR  phObject            //! points to the location that receives that list of additional object handles
        , CK_ULONG              ulMaxObjectCount    //! is the maximum number of object handles to be returned
        , CK_ULONG_PTR          pulObjectCount      //! points to the location that receives the actual number of object handles returned
    );
#if defined(__BORLANDC__)
    AnsiString GetSlotDescription(void);
    AnsiString GetTokenLabel(void);

    __property AnsiString SlotDescription = {read=GetSlotDescription};
    __property AnsiString TokenLabel = {read=GetTokenLabel};
#endif
protected:
    /** get session info. */
    CK_RV GetSessionInfo(
        CK_STATE*               pState = NULL
    );
    /** opens a session between an application and a token in a particular slot. */
    CK_RV OpenSession(
        //! indicates the type of session
        CK_FLAGS                flags = CKF_RW_SESSION|CKF_SERIAL_SESSION
    );
    /** close a session between an application and a token. */
    CK_RV CloseSession(
        void
    );
    /** close all sessions an application has with a token. */
    CK_RV CloseAllSessions(
        void
    );
public:
    PKI_Token(PKI_Cryptoki* owner, CK_SLOT_ID slotid);
    ~PKI_Token();
private:
    CK_SLOT_ID                  slotID;
    CK_SESSION_HANDLE           hSession;
};
//---------------------------------------------------------------------------
#endif

PKIToken.cpp

 

//---------------------------------------------------------------------------

#pragma hdrstop

//#include "PKIError.h"
#include "PKICryptoki.h"
#include "PKIToken.h"

#define CryptokiOwner dynamic_cast<PKI_Cryptoki*>(Owner)
#define FunctionList  CryptokiOwner->pFunctionList
//---------------------------------------------------------------------------
PKI_Token::PKI_Token(PKI_Cryptoki* owner, CK_SLOT_ID slotid)
    : PKI_Container(owner), slotID(slotid), hSession(CK_INVALID_HANDLE)
{
    OpenSession();
}
//---------------------------------------------------------------------------
PKI_Token::~PKI_Token()
{
    CloseSession();
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::GetSessionInfo(CK_STATE* pState)
{
    CK_RV                       rv = CKR_OK;
    CK_SESSION_INFO             ckSessionInfo;

    rv = FunctionList->C_GetSessionInfo(hSession, &ckSessionInfo);
    if(CKR_OK==rv && pState) {
        *pState = ckSessionInfo.state;
    }

    return rv;
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::OpenSession(CK_FLAGS flags)
{
    CK_RV                       rv = CKR_OK;

    if(CKR_OK != GetSessionInfo()) {
        hSession = CK_INVALID_HANDLE;
    }
    if(CK_INVALID_HANDLE == hSession) {
        flags |= CKF_SERIAL_SESSION;
        rv = FunctionList->C_OpenSession(slotID
            , flags, this, NULL, &hSession);
        if(CKR_OK != rv) {
            hSession = CK_INVALID_HANDLE;
        }
    }

    return rv;
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::CloseSession(void)
{
    CK_RV                       rv = CKR_OK;

    if(CKR_OK != GetSessionInfo()) {
        hSession = CK_INVALID_HANDLE;
    }
    if(CK_INVALID_HANDLE != hSession) {
        rv = FunctionList->C_CloseSession(hSession);
        hSession = CK_INVALID_HANDLE;
    }

    return rv;
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::CloseAllSessions(void)
{
    CK_RV                       rv = CKR_OK;

    rv = FunctionList->C_CloseAllSessions(slotID);
    rv = (CKR_TOKEN_NOT_RECOGNIZED == rv) ? CKR_OK : rv;

    return rv;
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::GetSlotInfo(CK_SLOT_INFO_PTR pInfo)
{
    return CryptokiOwner->GetSlotInfo(slotID, pInfo);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::GetTokenInfo(CK_TOKEN_INFO_PTR pInfo)
{
    return CryptokiOwner->GetTokenInfo(slotID, pInfo);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::GetMechanismList(CK_MECHANISM_TYPE_PTR pMechanismList
    , CK_ULONG_PTR pulCount)
{
    return FunctionList->C_GetMechanismList(slotID, pMechanismList, pulCount);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::GetMechanismInfo(CK_MECHANISM_TYPE type
    , CK_MECHANISM_INFO_PTR pInfo)
{
    return FunctionList->C_GetMechanismInfo(slotID, type, pInfo);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::InitToken(CK_UTF8CHAR_PTR pPin
    , CK_ULONG ulPinLen, CK_UTF8CHAR_PTR pLabel)
{
    CK_RV                       rv = CKR_OK;

    CloseAllSessions();
    rv = FunctionList->C_InitToken(slotID, pPin, ulPinLen, pLabel);
    if(CKR_OK == rv) {
        OpenSession();
        LoginSO(pPin, ulPinLen);
    }

    return rv;
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::InitPIN(CK_UTF8CHAR_PTR pPin, CK_ULONG ulPinLen)
{
    CK_RV                       rv = CKR_OK;

    rv = FunctionList->C_InitPIN(hSession, pPin, ulPinLen);
    if(CKR_OK == rv) {
        CloseSession();
        OpenSession();
        Login(pPin, ulPinLen);
    }

    return rv;
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::SetPIN(CK_UTF8CHAR_PTR pOldPin
    , CK_ULONG ulOldLen, CK_UTF8CHAR_PTR pNewPin, CK_ULONG ulNewLen)
{
    return FunctionList->C_SetPIN(hSession
        , pOldPin, ulOldLen, pNewPin, ulNewLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::Login(CK_UTF8CHAR_PTR pPin, CK_ULONG ulPinLen)
{
    return FunctionList->C_Login(hSession, CKU_USER, pPin, ulPinLen);
}
#if defined(__BORLANDC__)
//---------------------------------------------------------------------------
#include "PKILoginDialog.h"
CK_RV PKI_Token::LoginDialog(void)
{
    CK_RV                       rv = CKR_CANCEL;
    CK_STATE                    ckState;
    CK_TOKEN_INFO               tokenInfo;

    if(CKR_OK != (rv = GetSessionInfo(&ckState))) {
        return rv;
    }
    
    if(CKS_RO_USER_FUNCTIONS==ckState || CKS_RW_USER_FUNCTIONS==ckState) {
        return CKR_OK;
    }

    if(CKR_OK != (rv = GetTokenInfo(&tokenInfo))) {
        return rv;
    }
    
    __try {
        frmPKILogin = new TfrmPKILogin(Application, &tokenInfo);
        if(mrOk == frmPKILogin->ShowModal()) {
            AnsiString          userPIN = frmPKILogin->edtPIN->Text;

            rv = Login(userPIN.c_str(), userPIN.Length());
        }   else {
            rv = CKR_CANCEL;
        }
    }   __finally {
        delete frmPKILogin;
    }

    return rv;
}
#endif
//---------------------------------------------------------------------------
CK_RV PKI_Token::LoginSO(CK_UTF8CHAR_PTR pSOPin, CK_ULONG ulSOPinLen)
{
    return FunctionList->C_Login(hSession, CKU_SO, pSOPin, ulSOPinLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::Logout(void)
{
    return FunctionList->C_Logout(hSession);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::SeedRandom(CK_BYTE_PTR pSeed, CK_ULONG ulSeedLen)
{
    return FunctionList->C_SeedRandom(hSession, pSeed, ulSeedLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::GenerateRandom(CK_BYTE_PTR pRandomData, CK_ULONG ulRandomLen)
{
    return FunctionList->C_GenerateRandom(hSession, pRandomData, ulRandomLen);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::CreateObject(CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount
    , CK_OBJECT_HANDLE_PTR phObject)
{
    return FunctionList->C_CreateObject(hSession, pTemplate, ulCount, phObject);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::GenerateKey(CK_MECHANISM_PTR pMechanism
    , CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount
    , CK_OBJECT_HANDLE_PTR phObject)
{
    return FunctionList->C_GenerateKey(hSession, pMechanism
        , pTemplate, ulCount, phObject);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::GenerateKeyPair(CK_MECHANISM_PTR pMechanism
    , CK_ATTRIBUTE_PTR pPublicKeyTemplate, CK_ULONG ulPublicKeyAttributeCount
    , CK_ATTRIBUTE_PTR pPrivateKeyTemplate, CK_ULONG ulPrivateKeyAttributeCount
    , CK_OBJECT_HANDLE_PTR phPublicKey, CK_OBJECT_HANDLE_PTR phPrivateKey)
{
    return FunctionList->C_GenerateKeyPair(hSession, pMechanism
        , pPublicKeyTemplate, ulPublicKeyAttributeCount
        , pPrivateKeyTemplate, ulPrivateKeyAttributeCount
        , phPublicKey, phPrivateKey);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::FindObjectsInit(CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount)
{
    return FunctionList->C_FindObjectsInit(hSession, pTemplate, ulCount);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::FindObjects(CK_OBJECT_HANDLE_PTR phObject
    , CK_ULONG ulMaxObjectCount, CK_ULONG_PTR pulObjectCount)
{
    return FunctionList->C_FindObjects(hSession
        , phObject, ulMaxObjectCount, pulObjectCount);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::FindObjectsFinal(void)
{
    return FunctionList->C_FindObjectsFinal(hSession);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::FindObjects(CK_ATTRIBUTE_PTR pTemplate, CK_ULONG ulCount
    , CK_OBJECT_HANDLE_PTR phObject, CK_ULONG ulMaxObjectCount
    , CK_ULONG_PTR pulObjectCount)
{
    CK_RV                       rv = CKR_OK;

    if(CKR_OK != (rv = FindObjectsInit(pTemplate, ulCount))) {
        return rv;
    }
    
    rv = FindObjects(phObject, ulMaxObjectCount, pulObjectCount);
    FindObjectsFinal();

    return rv;
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::FindObjectByClass(CK_OBJECT_CLASS objClass
    , CK_OBJECT_HANDLE_PTR phObject, CK_ULONG ulMaxObjectCount
    , CK_ULONG_PTR pulObjectCount)
{
    CK_ATTRIBUTE                Template[1] = {
        {   CKA_CLASS,          &objClass,          sizeof(objClass)    }
    };

    return FindObjects(Template, 1, phObject, ulMaxObjectCount, pulObjectCount);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::FindObjectByID(CK_BYTE_PTR pID, CK_ULONG ulIDLen
    , CK_OBJECT_HANDLE_PTR phObject, CK_ULONG ulMaxObjectCount
    , CK_ULONG_PTR pulObjectCount)
{
    CK_ATTRIBUTE                Template[1] = {
        {   CKA_ID,             pID,                ulIDLen             }
    };

    return FindObjects(Template, 1, phObject, ulMaxObjectCount, pulObjectCount);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::FindObjectByLabel(CK_UTF8CHAR_PTR pLabel, CK_ULONG ulLabelLen
    , CK_OBJECT_HANDLE_PTR phObject, CK_ULONG ulMaxObjectCount
    , CK_ULONG_PTR pulObjectCount)
{
    CK_ATTRIBUTE                Template[1] = {
        {   CKA_LABEL,          pLabel,             ulLabelLen          }
    };

    return FindObjects(Template, 1, phObject, ulMaxObjectCount, pulObjectCount);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::FindObjectByClassID(CK_OBJECT_CLASS objClass
    , CK_BYTE_PTR pID, CK_ULONG ulIDLen, CK_OBJECT_HANDLE_PTR phObject
    , CK_ULONG ulMaxObjectCount, CK_ULONG_PTR pulObjectCount)
{
    CK_ATTRIBUTE                Template[2] = {
        {   CKA_CLASS,          &objClass,          sizeof(objClass)    },
        {   CKA_ID,             pID,                ulIDLen             }
    };

    return FindObjects(Template, 2, phObject, ulMaxObjectCount, pulObjectCount);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::FindObjectByClassLabel(CK_OBJECT_CLASS objClass
    , CK_UTF8CHAR_PTR pLabel, CK_ULONG ulLabelLen, CK_OBJECT_HANDLE_PTR phObject
    , CK_ULONG ulMaxObjectCount, CK_ULONG_PTR pulObjectCount)
{
    CK_ATTRIBUTE                Template[2] = {
        {   CKA_CLASS,          &objClass,          sizeof(objClass)    },
        {   CKA_LABEL,          pLabel,             ulLabelLen          }
    };

    return FindObjects(Template, 2, phObject, ulMaxObjectCount, pulObjectCount);
}
//---------------------------------------------------------------------------
CK_RV PKI_Token::FindObjectByIDLabel(CK_BYTE_PTR pID, CK_ULONG ulIDLen
    , CK_UTF8CHAR_PTR pLabel, CK_ULONG ulLabelLen, CK_OBJECT_HANDLE_PTR phObject
    , CK_ULONG ulMaxObjectCount, CK_ULONG_PTR pulObjectCount)
{
    CK_ATTRIBUTE                Template[2] = {
        {   CKA_ID,             pID,                ulIDLen             },
        {   CKA_LABEL,          pLabel,             ulLabelLen          }
    };

    return FindObjects(Template, 2, phObject, ulMaxObjectCount, pulObjectCount);
}
//---------------------------------------------------------------------------
AnsiString PKI_Token::GetSlotDescription(void)
{
    CK_SLOT_INFO                slotInfo;

    if(CKR_OK == GetSlotInfo(&slotInfo)) {
        return AnsiString((char*)slotInfo.slotDescription, 64).TrimRight();
    }   else {
        return AnsiString();
    }
}
//---------------------------------------------------------------------------
AnsiString PKI_Token::GetTokenLabel(void)
{
    CK_TOKEN_INFO               tokenInfo;

    if(CKR_OK == GetTokenInfo(&tokenInfo)) {
        return AnsiString((char*)tokenInfo.label, 32).TrimRight();
    }   else {
        return GetSlotDescription();
    }
}
//---------------------------------------------------------------------------



Trackback: http://tb.blog.csdn.net/TrackBack.aspx?PostId=26878
